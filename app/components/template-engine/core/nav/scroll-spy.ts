// app/components/template-engine/core/nav/scroll-spy.ts

"use client";

export type ScrollSpyOptions = {
  /**
   * CSS selector for sections to observe.
   * Default: '[id^="sec-"]'
   */
  selector?: string;

  /**
   * A function returning the current header offset in px (for scroll-margin / rootMargin logic).
   * If omitted, we try to read CSS var --header-offset, then fallback to 84.
   */
  getHeaderOffsetPx?: () => number;

  /**
   * Called when active section changes (section DOM id, e.g. "sec-services")
   */
  onActiveChange: (activeDomId: string | null) => void;

  /**
   * IntersectionObserver threshold(s)
   */
  threshold?: number | number[];

  /**
   * Root margin (string). If not provided, we build one using header offset:
   * activates when section crosses mid-screen band.
   */
  rootMargin?: string;
};

function readCssVarPx(name: string, fallback: number): number {
  if (typeof window === "undefined") return fallback;
  const raw = getComputedStyle(document.documentElement)
    .getPropertyValue(name)
    .trim();
  const n = Number(raw.replace("px", "").trim());
  return Number.isFinite(n) ? n : fallback;
}

function defaultHeaderOffset(): number {
  // prefer --header-offset if you set it, else 84
  return readCssVarPx("--header-offset", 84);
}

function getViewportH(): number {
  if (typeof window === "undefined") return 800;
  return window.innerHeight || 800;
}

/**
 * ScrollSpy â€” V24 Canon
 * - observes ONLY ids generated by dom-ids.ts (default selector: [id^="sec-"])
 * - chooses the "most active" section (highest intersection ratio)
 * - stable across fast scrolls and avoids skipping
 */
export function createScrollSpy(opts: ScrollSpyOptions) {
  const selector = opts.selector ?? '[id^="sec-"]';
  const threshold = opts.threshold ?? [0, 0.1, 0.25, 0.5, 0.75, 1];

  const getHeaderOffsetPx = opts.getHeaderOffsetPx ?? defaultHeaderOffset;

  let io: IntersectionObserver | null = null;
  let destroyed = false;

  // track latest ratios per element
  const ratios = new Map<string, number>();
  let lastActive: string | null = null;

  const pickBestActive = () => {
    if (ratios.size === 0) return null;

    let bestId: string | null = null;
    let bestRatio = 0;

    for (const [id, r] of ratios.entries()) {
      if (r > bestRatio) {
        bestRatio = r;
        bestId = id;
      }
    }

    // if nothing is actually visible, return null
    if (!bestId || bestRatio <= 0) return null;
    return bestId;
  };

  const emitIfChanged = () => {
    const next = pickBestActive();
    if (next !== lastActive) {
      lastActive = next;
      opts.onActiveChange(next);
    }
  };

  const buildRootMargin = () => {
    if (opts.rootMargin) return opts.rootMargin;

    // We activate when section is within the "middle band" of viewport
    // while accounting for header height at the top.
    const header = Math.max(0, getHeaderOffsetPx());
    const vh = getViewportH();

    // middle band: shrink top by ~40% vh + header, shrink bottom by ~50% vh
    const top = -(Math.floor(vh * 0.4) + header);
    const bottom = -Math.floor(vh * 0.5);

    return `${top}px 0px ${bottom}px 0px`;
  };

  const connect = () => {
    if (destroyed) return;

    const nodes = Array.from(document.querySelectorAll<HTMLElement>(selector));
    if (nodes.length === 0) {
      // no sections yet (maybe during first render)
      opts.onActiveChange(null);
      return;
    }

    // reset state
    ratios.clear();
    lastActive = null;

    if (io) io.disconnect();

    io = new IntersectionObserver(
      (entries) => {
        for (const e of entries) {
          const el = e.target as HTMLElement;
          const id = el.id;
          if (!id) continue;

          // intersectionRatio is stable; treat non-intersecting as 0
          ratios.set(id, e.isIntersecting ? e.intersectionRatio : 0);
        }
        emitIfChanged();
      },
      {
        root: null,
        threshold,
        rootMargin: buildRootMargin(),
      }
    );

    for (const n of nodes) {
      if (!n.id) continue;
      io.observe(n);
      ratios.set(n.id, 0);
    }

    // initial pass (in case we start mid page)
    emitIfChanged();
  };

  // rebuild on resize (rootMargin depends on viewport)
  const onResize = () => {
    if (destroyed) return;
    connect();
  };

  window.addEventListener("resize", onResize, { passive: true });

  // allow manual refresh (e.g. after sections list changes)
  const refresh = () => {
    if (destroyed) return;
    connect();
  };

  // initial connect
  queueMicrotask(connect);

  const destroy = () => {
    destroyed = true;
    window.removeEventListener("resize", onResize);
    if (io) io.disconnect();
    io = null;
    ratios.clear();
    lastActive = null;
  };

  return { refresh, destroy };
}

/**
 * Helper: smooth scroll to a section by DOM id, respecting header offset.
 * Optional but practical for consistent behavior.
 */
export function scrollToDomId(
  domId: string,
  opts?: { behavior?: ScrollBehavior }
) {
  const el = document.getElementById(domId);
  if (!el) return;

  // We rely on scrollMarginTop on the section wrapper.
  el.scrollIntoView({ behavior: opts?.behavior ?? "smooth", block: "start" });
}
